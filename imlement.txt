<Plan>
1.  **Add State for Sync Status:** Introduce a new boolean state variable `isSyncedToImage` in `ARViewModel` to track whether the initial image-based synchronization has occurred for the current session.
2.  **Add Re-Sync Function:** Create a method `triggerImageSync()` in `ARViewModel` to reset `isSyncedToImage` to `false`, allowing the sync process to happen again.
3.  **Modify Image Anchor Handling (visionOS):** In `XRAnatomy_visionOSApp.swift`, update the `startImageMonitoring` function. When an image anchor is detected (`.added` or `.updated` and `isTracked`), check `arViewModel.isSyncedToImage`. If `false`, update the `sharedAnchorEntity` transform and set `isSyncedToImage` to `true`. If `true`, *do not* update the `sharedAnchorEntity` transform from the image anchor anymore, even if the image remains tracked. Update the `appState.isImageTracked` flag based on detection status only.
4.  **Modify Image Anchor Handling (iOS):** In `ARSessionDelegateHandler.swift`, apply the same logic as visionOS within the `session(_:didAdd:)` and `session(_:didUpdate:)` methods for `ARImageAnchor`. Use the `arViewModel.isSyncedToImage` flag to control when `sharedAnchorEntity` is updated.
5.  **Add UI Button (visionOS):** In `DebugControlsView.swift`, add a button labeled "Re-Sync Image" that calls `arViewModel.triggerImageSync()` when pressed and when `currentSyncMode` is `.imageTarget`.
6.  **Add UI Button (iOS):** In `BottomSheet.swift` (specifically `SettingsView`), add a similar "Re-Sync Image" button that calls `arViewModel.triggerImageSync()` when `currentSyncMode` is `.imageTarget`.
7.  **Update Status Indicators:** Modify UI elements (like in `DebugControlsView` or `ConnectionStatusView`) to reflect the "Synced via Image" or "Awaiting Image Sync" status when in `.imageTarget` mode based on the `isSyncedToImage` flag.
</Plan>

<file path="/Users/alikara/Desktop/CPSC 599/XR-Anatomy-App-2 copy 2/Shared/ARViewModel.swift" action="modify">
  <change>
    <description>Add isSyncedToImage state variable</description>
    <search>
===
    // Shared anchor for image target mode (used by both platforms)
    let sharedAnchorEntity = AnchorEntity(.world(transform: matrix_identity_float4x4))
    @Published var isImageTracked: Bool = false // Track if the target image is currently tracked

    // RealityKit Scene (available on both iOS and visionOS)
===
    </search>
    <content>
===
    // Shared anchor for image target mode (used by both platforms)
    let sharedAnchorEntity = AnchorEntity(.world(transform: matrix_identity_float4x4))
    @Published var isImageTracked: Bool = false // Track if the target image is *currently* detected/tracked
    @Published var isSyncedToImage: Bool = false // Track if the initial sync alignment via image has occurred

    // RealityKit Scene (available on both iOS and visionOS)
===
    </content>
  </change>
  <change>
    <description>Add triggerImageSync function</description>
    <search>
===
        }
    }

    // MARK: - Multipeer Connectivity
===
    </search>
    <content>
===
        }
    }

    // MARK: - Image Sync Control

    /// Resets the image sync state, allowing detection to re-align the shared anchor.
    @MainActor func triggerImageSync() {
        if currentSyncMode == .imageTarget {
            isSyncedToImage = false
            isImageTracked = false // Reset detection status as well
            print("Image sync triggered. Awaiting image target detection for re-alignment.")
            // Optionally, provide user feedback (e.g., alert)
            alertItem = AlertItem(title: "Image Sync", message: "Point your device towards the designated image target to re-align the session.")
        } else {
            print("Cannot trigger image sync when not in Image Target mode.")
        }
    }

    // MARK: - Multipeer Connectivity
===
    </content>
  </change>
  <change>
    <description>Reset isSyncedToImage when stopping multipeer services</description>
    <search>
===
        self.connectedPeers.removeAll()
        self.availableSessions.removeAll()
        self.selectedSession = nil
        print("Stopped and cleaned up multipeer services.")
    }
===
    </search>
    <content>
===
        self.connectedPeers.removeAll()
        self.availableSessions.removeAll()
        self.selectedSession = nil
        self.isSyncedToImage = false // Reset sync status on disconnect
        self.isImageTracked = false
        print("Stopped and cleaned up multipeer services.")
    }
===
    </content>
  </change>
  <change>
    <description>Reset isSyncedToImage in resetARSession (iOS)</description>
    <search>
===
        self.placedAnchors.removeAll()
        self.processedAnchorIDs.removeAll()
        self.modelManager?.reset() // Also reset models managed by ModelManager
        self.isSyncedToImage = false // Reset sync status
        self.isImageTracked = false
===
    </search>
    <content>
===
        self.placedAnchors.removeAll()
        self.processedAnchorIDs.removeAll()
        self.modelManager?.reset() // Also reset models managed by ModelManager
        self.isSyncedToImage = false // Reset sync status
        self.isImageTracked = false
===
    </content>
  </change>
</file>

<file path="/Users/alikara/Desktop/CPSC 599/XR-Anatomy-App-2 copy 2/XR Anatomy Vision/XRAnatomy_visionOSApp.swift" action="modify">
  <change>
    <description>Modify image anchor monitoring logic to use isSyncedToImage flag</description>
    <search>
===
                    // Using the AppState object directly within the MainActor context
                    switch event {
                    case .added, .updated:
                        if imageAnchor.isTracked {
                            let newWorldTransform = imageAnchor.originFromAnchorTransform
                            arViewModel.sharedAnchorEntity.setTransformMatrix(newWorldTransform, relativeTo: nil)
                            
                            if !appState.isImageTracked {
                                print("‚úÖ Image Target '\(imageName)' detected and tracked. Updated sharedAnchorEntity.")
                            }
                            appState.isImageTracked = true
                        } else {
                            if appState.isImageTracked {
                                print("‚ö†Ô∏è Image Target '\(imageName)' lost tracking.")
                                appState.isImageTracked = false
                            }
                        }
                    case .removed:
                        if appState.isImageTracked {
                            print("‚ùå Image Target '\(imageName)' anchor removed.")
                            appState.isImageTracked = false
                        }
                    @unknown default:
                        print("Unhandled image anchor event: \(event)")
                    }
                } // End loop (anchorUpdates)
            } catch {
===
    </search>
    <content>
===
                    // Using the AppState and ARViewModel objects directly within the MainActor context
                    switch event {
                    case .added, .updated:
                        let imageName = imageAnchor.referenceImage.name ?? "Unknown"
                        if imageAnchor.isTracked {
                            // Image is currently tracked
                            if !arViewModel.isSyncedToImage {
                                // Perform the one-time sync alignment
                                let newWorldTransform = imageAnchor.originFromAnchorTransform
                                arViewModel.sharedAnchorEntity.setTransformMatrix(newWorldTransform, relativeTo: nil)
                                arViewModel.isSyncedToImage = true // Mark as synced
                                appState.isImageTracked = true // Mark as detected
                                print("‚úÖ Image Target '\(imageName)' detected. Synced sharedAnchorEntity transform.")
                            } else {
                                // Already synced, just update detection status if it wasn't already tracked
                                if !appState.isImageTracked {
                                     appState.isImageTracked = true
                                     print("üëÄ Image Target '\(imageName)' re-detected (already synced).")
                                }
                            }
                        } else {
                            // Image is lost
                            if appState.isImageTracked {
                                print("‚ö†Ô∏è Image Target '\(imageName)' lost tracking.")
                                appState.isImageTracked = false
                                // DO NOT reset isSyncedToImage here - alignment persists
                            }
                        }
                    case .removed:
                        let imageName = imageAnchor.referenceImage.name ?? "Unknown"
                        if appState.isImageTracked {
                            print("‚ùå Image Target '\(imageName)' anchor removed.")
                            appState.isImageTracked = false
                            // DO NOT reset isSyncedToImage here
                        }
                    @unknown default:
                        print("Unhandled image anchor event: \(event)")
                    }
                } // End loop (anchorUpdates)
            } catch {
===
    </content>
  </change>
  <change>
    <description>Ensure isImageTracked is reset correctly when monitoring stops</description>
    <search>
===
            // Ensure tracking state is false if task finishes
            if appState.isImageTracked {
                print("Image monitoring finished, resetting tracking state.")
                appState.isImageTracked = false
            }
        }
    }
}
===
    </search>
    <content>
===
            // Ensure detection state is false if task finishes or exits loop
            // isSyncedToImage persists until explicitly reset
            if appState.isImageTracked {
                print("Image monitoring loop finished/exited, resetting detection state.")
                appState.isImageTracked = false
            }
        }
    }
}
===
    </content>
  </change>
</file>

<file path="/Users/alikara/Desktop/CPSC 599/XR-Anatomy-App-2 copy 2/Shared/ARSessionDelegateHandler.swift" action="modify">
  <change>
    <description>Modify iOS image anchor handling for one-off sync</description>
    <search>
===
                } else if let imageAnchor = anchor as? ARImageAnchor {
                    print("Image anchor detected: \(imageAnchor.referenceImage.name ?? "unknown")")
                    // Update shared anchor transform based on image anchor
                    // Access arViewModel properties safely within the main queue block
                    arViewModel.sharedAnchorEntity.setTransformMatrix(imageAnchor.transform, relativeTo: nil)
                    arViewModel.isImageTracked = imageAnchor.isTracked // Update tracking status
                    
                    // If sync mode is image target, notify that the anchor is found
                    if arViewModel.currentSyncMode == .imageTarget {
                        // Potentially trigger synchronization of models relative to this anchor
                        print("Image anchor added/updated in Image Target mode.")
                    }
                // Removed handling for user-placed anchors (arViewModel.placedAnchors)
                // Placement is now handled directly in ARViewModel.handleTap
                } else {
                     // Log other unknown anchor types if necessary
                     // print("Ignoring unknown anchor type added: \(anchor.identifier), Type: \(type(of: anchor))")
                }
            }
        }
    }
    
    func session(_ session: ARSession, didUpdate anchors: [ARAnchor]) {
        // Use weak self to avoid retain cycles in async blocks
        DispatchQueue.main.async { [weak self] in
            guard let self = self, let arViewModel = self.arViewModel else { return }
            
            for anchor in anchors {
                if let imageAnchor = anchor as? ARImageAnchor {
                    // Update shared anchor transform and tracking status
                    if imageAnchor.isTracked {
                        arViewModel.sharedAnchorEntity.setTransformMatrix(imageAnchor.transform, relativeTo: nil)
                    }
                    // Only update state if it changed
                    if arViewModel.isImageTracked != imageAnchor.isTracked {
                        arViewModel.isImageTracked = imageAnchor.isTracked
                        print("Image anchor tracking status changed: \(arViewModel.isImageTracked)")
                    }
                }
            }
        }
    }
    
    func session(_ session: ARSession, didRemove anchors: [ARAnchor]) {
        // Use weak self to avoid retain cycles in async blocks
        DispatchQueue.main.async { [weak self] in
            guard let self = self, let arViewModel = self.arViewModel else { return }
            
            for anchor in anchors {
                if let imageAnchor = anchor as? ARImageAnchor {
                    print("Image anchor removed: \(imageAnchor.referenceImage.name ?? "unknown")")
                    if arViewModel.isImageTracked {
                        arViewModel.isImageTracked = false // Mark as not tracked
                    }
                }
                // Clean up associated content if needed
                arViewModel.processedAnchorIDs.remove(anchor.identifier)
===
    </search>
    <content>
===
                } else if let imageAnchor = anchor as? ARImageAnchor {
                    let imageName = imageAnchor.referenceImage.name ?? "unknown"
                    // Handle only when in image target mode
                    guard arViewModel.currentSyncMode == .imageTarget else { continue }

                    if imageAnchor.isTracked {
                        if !arViewModel.isSyncedToImage {
                            // Perform one-time sync
                            arViewModel.sharedAnchorEntity.setTransformMatrix(imageAnchor.transform, relativeTo: nil)
                            arViewModel.isSyncedToImage = true
                            arViewModel.isImageTracked = true
                            print("‚úÖ [iOS] Image Target '\(imageName)' detected. Synced sharedAnchorEntity.")
                        } else {
                            // Already synced, just update detection status
                            if !arViewModel.isImageTracked {
                                arViewModel.isImageTracked = true
                                print("üëÄ [iOS] Image Target '\(imageName)' re-detected (already synced).")
                            }
                        }
                    } else {
                        // Image lost tracking (but might still exist as an anchor)
                        if arViewModel.isImageTracked {
                            arViewModel.isImageTracked = false
                            print("‚ö†Ô∏è [iOS] Image Target '\(imageName)' lost tracking.")
                            // Do not reset isSyncedToImage
                        }
                    }
                } else {
                     // Log other unknown anchor types if necessary
                     // print("Ignoring unknown anchor type added: \(anchor.identifier), Type: \(type(of: anchor))")
                }
            }
        }
    }

    func session(_ session: ARSession, didUpdate anchors: [ARAnchor]) {
        // Use weak self to avoid retain cycles in async blocks
        DispatchQueue.main.async { [weak self] in
            guard let self = self, let arViewModel = self.arViewModel else { return }

            for anchor in anchors {
                if let imageAnchor = anchor as? ARImageAnchor {
                    let imageName = imageAnchor.referenceImage.name ?? "unknown"
                    // Handle only when in image target mode
                    guard arViewModel.currentSyncMode == .imageTarget else { continue }

                    if imageAnchor.isTracked {
                        if !arViewModel.isSyncedToImage {
                            // Perform one-time sync if detected during update
                            arViewModel.sharedAnchorEntity.setTransformMatrix(imageAnchor.transform, relativeTo: nil)
                            arViewModel.isSyncedToImage = true
                            arViewModel.isImageTracked = true
                            print("‚úÖ [iOS] Image Target '\(imageName)' detected via update. Synced sharedAnchorEntity.")
                        } else {
                            // Already synced, just update detection status
                             if !arViewModel.isImageTracked {
                                 arViewModel.isImageTracked = true
                                 print("üëÄ [iOS] Image Target '\(imageName)' re-detected via update (already synced).")
                             }
                        }
                    } else {
                        // Image lost tracking
                        if arViewModel.isImageTracked {
                            arViewModel.isImageTracked = false
                            print("‚ö†Ô∏è [iOS] Image Target '\(imageName)' lost tracking via update.")
                            // Do not reset isSyncedToImage
                        }
                    }
                }
            }
        }
    }

    func session(_ session: ARSession, didRemove anchors: [ARAnchor]) {
        // Use weak self to avoid retain cycles in async blocks
        DispatchQueue.main.async { [weak self] in
            guard let self = self, let arViewModel = self.arViewModel else { return }

            for anchor in anchors {
                if let imageAnchor = anchor as? ARImageAnchor {
                     let imageName = imageAnchor.referenceImage.name ?? "unknown"
                     // Handle only when in image target mode
                     guard arViewModel.currentSyncMode == .imageTarget else { continue }

                    print("‚ùå [iOS] Image Target '\(imageName)' anchor removed.")
                    if arViewModel.isImageTracked {
                        arViewModel.isImageTracked = false // Mark as not detected
                        // Do not reset isSyncedToImage
                    }
                }
                // Clean up associated content if needed
                arViewModel.processedAnchorIDs.remove(anchor.identifier)
===
    </content>
  </change>
</file>

<file path="/Users/alikara/Desktop/CPSC 599/XR-Anatomy-App-2 copy 2/XR Anatomy Vision/Scenes/DebugControlsView.swift" action="modify">
  <change>
    <description>Add Re-Sync Image button and status indicator</description>
    <search>
                        }
                        .padding(.top, 4)
                    }
                }
                .padding(.vertical, 8)
                .background(Color.secondary.opacity(0.1))
                .cornerRadius(8)
                
                // Test Message Button
                Button("Send Test Message") {
===
    </search>
    <content>
===
                        }
                        .padding(.top, 4)

                        // Sync Status and Re-Sync Button
                        if arViewModel.isSyncedToImage {
                            HStack {
                                Image(systemName: "checkmark.circle.fill")
                                    .foregroundColor(.green)
                                Text("Synced via Image")
                                    .font(.caption)
                                Spacer()
                                Button("Re-Sync") {
                                    arViewModel.triggerImageSync()
                                    lastAction = "Triggered Image Re-Sync"
                                }
                                .buttonStyle(.bordered)
                                .controlSize(.small)
                            }
                            .padding(.top, 4)
                        } else {
                             Text("Awaiting Image Sync...")
                                 .font(.caption)
                                 .foregroundColor(.orange)
                                 .padding(.top, 4)
                        }
                    }
                }
                .padding(.vertical, 8)
                .background(Color.secondary.opacity(0.1))
                .cornerRadius(8)

                // Test Message Button
                Button("Send Test Message") {
===
    </content>
  </change>
</file>

<file path="/Users/alikara/Desktop/CPSC 599/XR-Anatomy-App-2 copy 2/XR Anatomy/BottomSheet.swift" action="modify">
  <change>
    <description>Add Re-Sync Image button to iOS SettingsView</description>
    <search>
                      .foregroundColor(.secondary)
             }
             #endif
 
             Spacer()
             Button("Close") {
===
    </search>
    <content>
===
                      .foregroundColor(.secondary)
             }

             // Sync Mode Picker (Example - Adapt as needed for iOS UI)
             Picker("Sync Mode", selection: $arViewModel.currentSyncMode) {
                 ForEach(SyncMode.allCases, id: \.self) { mode in
                     Text(mode.rawValue).tag(mode)
                 }
             }
             .pickerStyle(.segmented)
             .onChange(of: arViewModel.currentSyncMode) { _, newMode in
                 print("iOS Sync Mode changed to: \(newMode.rawValue)")
                 // Add logic to reconfigure session if needed, e.g., add/remove image tracking
                 // This might involve pausing and re-running the ARSession with a new configuration.
                 // For now, just log the change.
                 // Consider posting a notification like in visionOS if session reconfiguration is complex.
                 arViewModel.isSyncedToImage = false // Reset sync status when mode changes
                 arViewModel.isImageTracked = false
             }

             // Image Sync Status and Button
             if arViewModel.currentSyncMode == .imageTarget {
                 HStack {
                     Circle()
                         .fill(arViewModel.isImageTracked ? Color.green : (arViewModel.isSyncedToImage ? Color.blue : Color.red))
                         .frame(width: 10, height: 10)

                     if arViewModel.isSyncedToImage {
                         Text(arViewModel.isImageTracked ? "Image Detected (Synced)" : "Synced via Image (Not Detected)")
                             .font(.caption)
                     } else {
                         Text(arViewModel.isImageTracked ? "Image Detected (Syncing...)" : "Awaiting Image Sync...")
                             .font(.caption)
                             .foregroundColor(.orange)
                     }
                 }
                 Button("Re-Sync Image") {
                     arViewModel.triggerImageSync()
                 }
                 .buttonStyle(.bordered)
                 .disabled(arViewModel.currentSyncMode != .imageTarget)
                 .padding(.top, 5)
             }


             #endif

             Spacer()
             Button("Close") {
===
    </content>
  </change>
</file>