<Plan>
1.  **Fix Object Target Loading:** Modify `XRAnatomy_visionOSApp.swift` to correctly load the `model-mobile.referenceobject` file, ensuring it checks the `models` subdirectory first and then the main bundle as a fallback, mirroring the logic used for `.usdz` files. Also, apply similar robust loading logic to the iOS part in `ARViewModel.swift`.
2.  **Fix Duplicate Window Opening:** Simplify the `toggleDebugModeUI` function in `AppModel.swift` to remove the delay and timestamp logic, directly posting the notification once. This should prevent duplicate panel openings.
3.  **Refine Parenting Logic:** Adjust the `update` block in `InSession.swift` to more clearly determine the *intended* parent based on the `currentSyncMode` and only reparent the entity if its current parent doesn't match the intended one. Add checks to ensure anchors are in the scene before parenting.
4.  **Verify File Inclusion (Manual Step):** Remind the user to ensure `Shared/models/model-mobile.referenceobject` is included in the "Copy Bundle Resources" build phase for the `XR Anatomy Vision` target in Xcode. (This cannot be done via code edits).
</Plan>

<file path="/Users/alikara/Desktop/CPSC 599/XR-Anatomy-App-2 copy 2/XR Anatomy Vision/XRAnatomy_visionOSApp.swift" action="modify">
  <change>
    <description>Improve reference object loading logic in configureARSession to check subdirectory first, then main bundle.</description>
    <search>
===
        } else if currentMode == .objectTarget {
            // --- Object Target Mode ---
            // Load the reference object from the bundle
            guard let referenceObjectURL = Bundle.main.url(forResource: "model-mobile", withExtension: "referenceobject", subdirectory: "models"),
                  let referenceObject = try? await ReferenceObject(from: referenceObjectURL) else {
                print("Error: Failed to load reference object 'model-mobile.referenceobject'")
                appState.alertItem = AlertItem(title: "Error", message: "Could not load Object Target resources. Switching back to World Sync.")
                arViewModel.currentSyncMode = .world
                await configureARSession() // Reconfigure for world mode
                return
            }
            print("Loaded reference object: \(referenceObject.name ?? "Unnamed")")

            let objectProvider = ObjectTrackingProvider(referenceObjects: [referenceObject])
            providers.append(objectProvider)
            appState.startObjectTracking(provider: objectProvider) // Use updated AppState method
        }
        // Else: World mode needs no extra provider beyond WorldTrackingProvider
===
    </search>
    <content>
===
        } else if currentMode == .objectTarget {
            // --- Object Target Mode ---
            var referenceObject: ReferenceObject?
            var loadedURL: URL?

            // Try loading from "models" subdirectory first
            if let objectURL = Bundle.main.url(forResource: "model-mobile", withExtension: "referenceobject", subdirectory: "models") {
                do {
                    referenceObject = try await ReferenceObject(from: objectURL)
                    loadedURL = objectURL
                    print("Successfully loaded reference object from models subdirectory.")
                } catch {
                    print("Info: Failed to load reference object from models subdirectory: \(error.localizedDescription). Trying main bundle.")
                    referenceObject = nil // Ensure it's nil if loading failed
                }
            }

            // Fallback: Try loading from the main bundle if not found or failed in subdirectory
            if referenceObject == nil, let objectURL = Bundle.main.url(forResource: "model-mobile", withExtension: "referenceobject") {
                 do {
                     referenceObject = try await ReferenceObject(from: objectURL)
                     loadedURL = objectURL
                     print("Successfully loaded reference object from main bundle.")
                 } catch {
                     print("Error: Failed to load reference object from main bundle: \(error.localizedDescription)")
                     referenceObject = nil // Ensure it's nil if loading failed
                 }
            }

            // Check if loading ultimately failed
            guard let finalReferenceObject = referenceObject else {
                print("Error: Failed to load reference object 'model-mobile.referenceobject' from any location.")
                appState.alertItem = AlertItem(title: "Error", message: "Could not load Object Target resources. Switching back to World Sync.")
                arViewModel.currentSyncMode = .world
                await configureARSession() // Reconfigure for world mode
                return
            }

            print("Loaded reference object: \(finalReferenceObject.name ?? "Unnamed") from \(loadedURL?.path ?? "Unknown Path")")

            let objectProvider = ObjectTrackingProvider(referenceObjects: [finalReferenceObject])
            providers.append(objectProvider)
            appState.startObjectTracking(provider: objectProvider) // Use updated AppState method
        }
        // Else: World mode needs no extra provider beyond WorldTrackingProvider
===
    </content>
  </change>
</file>

<file path="/Users/alikara/Desktop/CPSC 599/XR-Anatomy-App-2 copy 2/Shared/ARViewModel.swift" action="modify">
  <change>
    <description>Improve reference object loading logic in iOS reconfigureARSession to check subdirectory first, then main bundle.</description>
    <search>
===
        var referenceObjects = Set<ARReferenceObject>()
        if currentSyncMode == .objectTarget {
            // Load reference object with robust error handling
            // First try with models subdirectory
            if let objectURL = Bundle.main.url(forResource: "model-mobile", withExtension: "referenceobject", subdirectory: "models") {
                do {
                    let refObject = try ARReferenceObject(archiveURL: objectURL)
                    referenceObjects.insert(refObject)
                    print("[iOS] Successfully loaded reference object from models subdirectory")
                } catch {
                    print("[iOS] Error loading reference object from models subdirectory: \(error.localizedDescription)")
                    // Will try the fallback option below
                }
            } else if let objectURL = Bundle.main.url(forResource: "model-mobile", withExtension: "referenceobject") {
                // Fallback: try in the main bundle
                do {
                    let refObject = try ARReferenceObject(archiveURL: objectURL)
                    referenceObjects.insert(refObject)
                    print("[iOS] Successfully loaded reference object from main bundle")
                } catch {
                    print("[iOS] Error loading reference object from main bundle: \(error.localizedDescription)")
                    // Fall through to the failure case
                }
            }
            
            // If still empty, we failed to load the reference object
            if referenceObjects.isEmpty {
                print("[iOS] Error: Failed to load reference object 'model-mobile.referenceobject'. Switching to World Sync.")
                self.alertItem = AlertItem(title: "Error", message: "Could not load Object Target resources. Switching to World Sync.")
                currentSyncMode = .world
                reconfigureARSession()
                return
            }
            print("[iOS] Loaded reference object for Object Target mode.")
            // Reset sync state when switching TO object target mode
            self.isSyncedToObject = false
            self.isObjectTracked = false
            self.isSyncedToImage = false // Also reset image state
            self.isImageTracked = false
        }
===
    </search>
    <content>
===
        var referenceObjects = Set<ARReferenceObject>()
        if currentSyncMode == .objectTarget {
            var loadedObject: ARReferenceObject?
            var loadedURL: URL?

            // Try loading from "models" subdirectory first
            if let objectURL = Bundle.main.url(forResource: "model-mobile", withExtension: "referenceobject", subdirectory: "models") {
                do {
                    loadedObject = try ARReferenceObject(archiveURL: objectURL)
                    loadedURL = objectURL
                    print("[iOS] Successfully loaded reference object from models subdirectory.")
                } catch {
                    print("[iOS] Info: Failed to load reference object from models subdirectory: \(error.localizedDescription). Trying main bundle.")
                    loadedObject = nil // Ensure it's nil if loading failed
                }
            }

            // Fallback: Try loading from the main bundle if not found or failed in subdirectory
            if loadedObject == nil, let objectURL = Bundle.main.url(forResource: "model-mobile", withExtension: "referenceobject") {
                 do {
                     loadedObject = try ARReferenceObject(archiveURL: objectURL)
                     loadedURL = objectURL
                     print("[iOS] Successfully loaded reference object from main bundle.")
                 } catch {
                     print("[iOS] Error: Failed to load reference object from main bundle: \(error.localizedDescription)")
                     loadedObject = nil // Ensure it's nil if loading failed
                 }
            }

            // Check if loading ultimately failed
            if let finalReferenceObject = loadedObject {
                referenceObjects.insert(finalReferenceObject)
                print("[iOS] Loaded reference object: \(finalReferenceObject.name ?? "Unnamed") from \(loadedURL?.path ?? "Unknown Path")")
                // Reset sync state when switching TO object target mode
                self.isSyncedToObject = false
                self.isObjectTracked = false
                self.isSyncedToImage = false // Also reset image state
                self.isImageTracked = false
            } else {
                print("[iOS] Error: Failed to load reference object 'model-mobile.referenceobject' from any location. Switching to World Sync.")
                self.alertItem = AlertItem(title: "Error", message: "Could not load Object Target resources. Switching to World Sync.")
                currentSyncMode = .world
                reconfigureARSession() // Reconfigure for world mode
                return // Exit early as we are reconfiguring
            }
        }
===
    </content>
  </change>
</file>

<file path="/Users/alikara/Desktop/CPSC 599/XR-Anatomy-App-2 copy 2/XR Anatomy Vision/AppModel.swift" action="modify">
  <change>
    <description>Simplify toggleDebugModeUI to remove delay and timestamp, directly posting the notification.</description>
    <search>
===
    // Non-async version for UI bindings 
    func toggleDebugModeUI() {
        let wasEnabled = debugModeEnabled
        debugModeEnabled.toggle()
        print("Debug mode \(debugModeEnabled ? "enabled" : "disabled")")
        
        // Manage control panel visibility
        if debugModeEnabled && !wasEnabled {
            // Only open if not already visible and newly enabled
            if !controlPanelVisible {
                controlPanelVisible = true
                
                // Wait a short delay before opening to avoid multiple panels 
                DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
                    Task { @MainActor in
                        // Use unique timestamp to avoid duplicate notifications
                        NotificationCenter.default.post(
                            name: Notification.Name("openWindow"), 
                            object: nil, 
                            userInfo: [
                                "id": "controlPanel",
                                "timestamp": Date().timeIntervalSince1970
                            ]
                        )
                    }
                }
            }
        } else if !debugModeEnabled && wasEnabled {
            // When disabling debug mode, mark panel as closed
            controlPanelVisible = false
        }
    }
===
    </search>
    <content>
===
    // Non-async version for UI bindings
    func toggleDebugModeUI() {
        let wasEnabled = debugModeEnabled
        debugModeEnabled.toggle()
        print("Debug mode \(debugModeEnabled ? "enabled" : "disabled")")

        // Manage control panel visibility
        if debugModeEnabled && !wasEnabled {
            // Only open if not already visible and newly enabled
            if !controlPanelVisible {
                controlPanelVisible = true
                // Post notification immediately to open the window
                // Ensure this runs on the main thread if called from background
                DispatchQueue.main.async {
                    NotificationCenter.default.post(
                        name: Notification.Name("openWindow"),
                        object: nil,
                        userInfo: ["id": "controlPanel"]
                    )
                    print("Posted notification to open controlPanel")
                }
            }
        } else if !debugModeEnabled && wasEnabled {
            // When disabling debug mode, mark panel as closed
            // Note: We don't automatically close the window, just update the state.
            // The user needs to close the window manually.
            controlPanelVisible = false
            print("Debug mode disabled, control panel marked as closed (user must close window manually).")
        }
    }
===
    </content>
  </change>
</file>

<file path="/Users/alikara/Desktop/CPSC 599/XR-Anatomy-App-2 copy 2/XR Anatomy Vision/Scenes/InSession.swift" action="modify">
  <change>
    <description>Refine the parenting logic in the RealityView update block to prevent unnecessary reparenting loops when switching sync modes.</description>
    <search>
===
        } update: { content in
                // Ensure models are correctly parented based on sync mode
                for model in modelManager.placedModels {
                    guard let entity = model.modelEntity else { continue }

                    let targetParent: Entity?
                    if arViewModel.currentSyncMode == .imageTarget {
                        targetParent = arViewModel.sharedAnchorEntity
                        // Ensure shared anchor is in the scene if needed
                        if arViewModel.sharedAnchorEntity.scene == nil {
                            content.add(arViewModel.sharedAnchorEntity)
                            print("Added sharedAnchorEntity to content in update.")
                        }
                    } else {
                        targetParent = modelAnchor
                        // Ensure model anchor is in the scene
                        if modelAnchor.scene == nil {
                             content.add(modelAnchor)
                             print("Added modelAnchor to content in update.")
                        }
                    }

                    // If the entity has no parent or the wrong parent, add it to the correct one
                    if entity.parent != targetParent {
                        if let currentParent = entity.parent {
                             print("Removing \(entity.name) from incorrect parent \(currentParent.name)")
                             entity.removeFromParent()
                        }
                        
                        if let targetParent = targetParent {
                             targetParent.addChild(entity)
                             print("Added \(entity.name) to correct parent \(targetParent.name). SyncMode: \(arViewModel.currentSyncMode.rawValue)")
                             
                             // Set initial transform relative to the new parent if just added
                             if entity.transform == Transform() { // Check if transform is identity (likely just added)
                                 entity.setPosition([0, 0, 0], relativeTo: targetParent) // Position at parent's origin
                                 // Apply model-specific scaling
                                 if model.modelType.rawValue.lowercased() == "pancakes" {
                                     entity.scale = SIMD3<Float>(repeating: 0.08)
                                 } else if model.modelType.rawValue.lowercased() == "heart" ||
                                           model.modelType.rawValue.lowercased() == "arterieshead" {
                                     entity.scale = SIMD3<Float>(repeating: 0.2)
                                 } else {
                                     entity.scale = SIMD3<Float>(repeating: 0.15)
                                 }
                                 model.position = entity.position(relativeTo: targetParent)
                                 model.scale = entity.scale
                                 print("Set initial transform for \(entity.name) relative to \(targetParent.name)")
                             }
                        } else {
                             print("Warning: Target parent is nil for \(entity.name). Cannot add to scene.")
                        }
                    }
                }

                // Update model selection highlights and broadcast transforms
                // This function now assumes entities are correctly parented by the logic above.
                modelManager.updatePlacedModels(
                    arViewModel: arViewModel
                )
            }
            // --- visionOS Gestures ---
            .gesture(SpatialTapGesture()
===
    </search>
    <content>
===
        } update: { content in
                // Ensure models are correctly parented based on sync mode
                for model in modelManager.placedModels {
                    guard let entity = model.modelEntity else { continue }

                    // Determine the INTENDED parent based on the current sync mode
                    let intendedParent: Entity?
                    let intendedParentName: String
                    switch arViewModel.currentSyncMode {
                    case .imageTarget, .objectTarget:
                        // Ensure shared anchor is in the scene before considering it the intended parent
                        if arViewModel.sharedAnchorEntity.scene == nil {
                            // Check if it's in the RealityView content but not yet assigned to the scene graph
                            if content.entities.contains(arViewModel.sharedAnchorEntity) {
                                // It exists in content, likely okay to parent to, scene assignment might be pending
                                intendedParent = arViewModel.sharedAnchorEntity
                            } else {
                                // Not in content, add it first
                                content.add(arViewModel.sharedAnchorEntity)
                                print("Added sharedAnchorEntity to content in update (was missing).")
                                intendedParent = arViewModel.sharedAnchorEntity
                            }
                        } else {
                            intendedParent = arViewModel.sharedAnchorEntity
                        }
                        intendedParentName = "sharedAnchorEntity (\(arViewModel.currentSyncMode.rawValue))"
                    case .world:
                        // Ensure model anchor is in the scene
                        if modelAnchor.scene == nil {
                             if content.entities.contains(modelAnchor) {
                                 intendedParent = modelAnchor
                             } else {
                                 content.add(modelAnchor)
                                 print("Added modelAnchor to content in update (was missing).")
                                 intendedParent = modelAnchor
                             }
                        } else {
                            intendedParent = modelAnchor
                        }
                        intendedParentName = "modelAnchor (World)"
                    }

                    // Get the current parent
                    let currentParent = entity.parent

                    // Reparent ONLY if the current parent is different from the intended parent
                    if currentParent !== intendedParent {
                        // Log the reparenting action
                        print("Reparenting \(entity.name): Current parent (\(currentParent?.name ?? "nil")) != Intended parent (\(intendedParentName)). SyncMode: \(arViewModel.currentSyncMode.rawValue)")

                        // Ensure the intended parent is valid before reparenting
                        if let validIntendedParent = intendedParent {
                            // Preserve world transform during reparenting to avoid visual jumps
                            entity.setParent(validIntendedParent, preservingWorldTransform: true)
                            print("Successfully reparented \(entity.name) to \(intendedParentName).")

                            // After reparenting, update the model's local state if needed (optional)
                            // model.position = entity.position(relativeTo: validIntendedParent)
                            // model.rotation = entity.orientation(relativeTo: validIntendedParent)
                            // model.scale = entity.scale(relativeTo: validIntendedParent)

                        } else {
                            print("Warning: Cannot reparent \(entity.name) because intended parent (\(intendedParentName)) is nil or not ready.")
                            // If intended parent is nil, maybe remove the entity? Or leave it detached?
                            // For now, just log the warning.
                        }
                    }
                    // Else: Entity already has the correct parent, no action needed.
                }

                // Update model selection highlights and broadcast transforms
                // This function now assumes entities are correctly parented by the logic above.
                modelManager.updatePlacedModels(
                    arViewModel: arViewModel
                )
            }
            // --- visionOS Gestures ---
            .gesture(SpatialTapGesture()
===
    </content>
  </change>
</file>