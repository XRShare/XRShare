<Plan>
The primary issue is that the iOS `ARSessionManager` always configures a basic `ARWorldTrackingConfiguration` without enabling image detection, regardless of the `currentSyncMode` set in `ARViewModel`.

1.  **Modify `ARSessionManager.swift` (iOS):** Update the `configureSession` method to accept the `SyncMode` and the `ARReferenceImage` set. If the mode is `.imageTarget`, it will configure the session to detect those images using `ARWorldTrackingConfiguration`'s `detectionImages` property.
2.  **Modify `ARViewModel.swift` (iOS):**
    *   Update the `setupARView` method to load reference images and pass the `currentSyncMode` and images to the modified `configureSession`.
    *   Add a new method `reconfigureARSession()` to handle changes in `currentSyncMode`. This method will load reference images if needed and call the `ARSessionManager` to re-run the session with the appropriate configuration.
    *   Call `reconfigureARSession()` when `currentSyncMode` changes.
3.  **Modify `BottomSheet.swift` (iOS SettingsView):** In the `onChange` modifier for the `SyncMode` picker, call the new `reconfigureARSession()` method in `ARViewModel`.
</Plan>

<file path="/Users/alikara/Desktop/CPSC 599/XR-Anatomy-App-2 copy 2/Shared/ARSessionManager.swift" action="modify">
  <change>
    <description>Modify configureSession to accept SyncMode and reference images for iOS</description>
    <search>
===
import ARKit
import RealityKit

/// An AR session manager for iOS that configures an ARView's session.
class ARSessionManager {
    static let shared = ARSessionManager()
    private init() { }

    func configureSession(for arView: ARView) {
        let config = ARWorldTrackingConfiguration()
        config.planeDetection = [.horizontal, .vertical]
        if ARWorldTrackingConfiguration.supportsSceneReconstruction(.mesh) {
            config.sceneReconstruction = .meshWithClassification
        }
        config.environmentTexturing = .automatic
        config.isCollaborationEnabled = true
        
        arView.session.run(config, options: [.resetTracking, .removeExistingAnchors])
    }
}
#elseif os(visionOS)
===
    </search>
    <content>
===
import ARKit
import RealityKit

/// An AR session manager for iOS that configures an ARView's session.
class ARSessionManager {
    static let shared = ARSessionManager()
    private init() { }

    /// Configures the AR session based on the selected sync mode.
    /// - Parameters:
    ///   - arView: The ARView whose session needs configuration.
    ///   - syncMode: The desired synchronization mode (.world or .imageTarget).
    ///   - referenceImages: The set of reference images to detect (only used if syncMode is .imageTarget).
    func configureSession(for arView: ARView, syncMode: SyncMode, referenceImages: Set<ARReferenceImage> = Set()) {
        print("[iOS] Configuring ARSession for mode: \(syncMode.rawValue)")
        // Always use ARWorldTrackingConfiguration as it supports both world tracking and image detection.
        let config = ARWorldTrackingConfiguration()
        
        // Basic configuration applicable to both modes
        config.planeDetection = [.horizontal, .vertical]
        if ARWorldTrackingConfiguration.supportsSceneReconstruction(.mesh) {
            config.sceneReconstruction = .meshWithClassification
            print("[iOS] Scene Reconstruction enabled.")
        } else {
            print("[iOS] Scene Reconstruction not supported.")
        }
        config.environmentTexturing = .automatic
        config.isCollaborationEnabled = true // Essential for multipeer

        // Configure for Image Target mode
        if syncMode == .imageTarget {
            if referenceImages.isEmpty {
                print("[iOS] Warning: Image Target mode selected, but no reference images provided.")
                // Proceed with world tracking only, or handle error as needed
                config.detectionImages = Set() // Ensure it's empty
            } else {
                config.detectionImages = referenceImages
                // Set the maximum number of tracked images if needed (default is 1)
                config.maximumNumberOfTrackedImages = 1 // Adjust if you need to track multiple images simultaneously
                print("[iOS] Configured ARWorldTrackingConfiguration with \(referenceImages.count) detection images.")
            }
        } else {
            // Ensure detectionImages is empty for world mode
            config.detectionImages = Set()
            print("[iOS] Configured ARWorldTrackingConfiguration for World Space Sync.")
        }
        
        // Run the session with the new configuration
        // Reset tracking and remove existing anchors to apply the new settings cleanly
        arView.session.run(config, options: [.resetTracking, .removeExistingAnchors])
        print("[iOS] ARSession run with new configuration.")
    }
}
#elseif os(visionOS)
===
    </content>
  </change>
</file>

<file path="/Users/alikara/Desktop/CPSC 599/XR-Anatomy-App-2 copy 2/Shared/ARViewModel.swift" action="modify">
  <change>
    <description>Update setupARView to use the new configureSession and add reconfigureARSession method for iOS</description>
    <search>
===
    #if os(iOS)
    /// Setup the ARView with necessary configuration
    func setupARView(_ arView: ARView) {
        self.arView = arView
        self.setCurrentScene(arView.scene) // Set the scene

        // Configure the AR session using the shared manager
        self.arSessionManager.configureSession(for: arView)

        // Assign the custom delegate handler
        if let delegateHandler = self.arSessionDelegateHandler {
===
    </search>
    <content>
===
    #if os(iOS)
    /// Setup the ARView with necessary configuration
    func setupARView(_ arView: ARView) {
        self.arView = arView
        self.setCurrentScene(arView.scene) // Set the scene

        // Initial session configuration based on the current sync mode
        reconfigureARSession() // Call reconfigure to handle initial setup

        // Assign the custom delegate handler
        if let delegateHandler = self.arSessionDelegateHandler {
===
    </content>
  </change>
  <change>
    <description>Add reconfigureARSession method for iOS</description>
    <search>
===
        print("All models cleared")
    }

    // Removed placeModel(for:) as placement is now handled directly in handleTap

    /// Broadcasts model transform using the unified sendTransform method.
    func broadcastModelTransform(entity: Entity, modelType: ModelType) {
===
    </search>
    <content>
===
        print("All models cleared")
    }

    /// Reconfigures the ARKit session based on the current `currentSyncMode`. (iOS specific)
    @MainActor func reconfigureARSession() {
        guard let arView = self.arView else {
            print("[iOS] Cannot reconfigure ARSession: ARView not available.")
            return
        }
        print("[iOS] Reconfiguring ARSession for mode: \(currentSyncMode.rawValue)")

        var referenceImages = Set<ARReferenceImage>()
        if currentSyncMode == .imageTarget {
            // Load reference images from the asset catalog
            // Ensure the group name matches your Assets.xcassets
            guard let loadedImages = ARReferenceImage.referenceImages(inGroupNamed: "SharedAnchors", bundle: nil) else {
                print("[iOS] Error: Failed to load reference images from group 'SharedAnchors'. Switching to World Sync.")
                self.alertItem = AlertItem(title: "Error", message: "Could not load Image Target resources. Switching to World Sync.")
                // Fallback to world mode
                currentSyncMode = .world
                // Call reconfigure again with the updated mode
                reconfigureARSession()
                return
            }
            referenceImages = loadedImages
            print("[iOS] Loaded \(referenceImages.count) reference images for Image Target mode.")
            // Reset sync state when switching TO image target mode
            self.isSyncedToImage = false
            self.isImageTracked = false
        } else {
             // Reset sync state when switching FROM image target mode
             self.isSyncedToImage = false
             self.isImageTracked = false
        }

        // Configure the session using the manager
        self.arSessionManager.configureSession(
            for: arView,
            syncMode: currentSyncMode,
            referenceImages: referenceImages
        )
    }

    // Removed placeModel(for:) as placement is now handled directly in handleTap

    /// Broadcasts model transform using the unified sendTransform method.
    func broadcastModelTransform(entity: Entity, modelType: ModelType) {
===
    </content>
  </change>
</file>

<file path="/Users/alikara/Desktop/CPSC 599/XR-Anatomy-App-2 copy 2/XR Anatomy/BottomSheet.swift" action="modify">
  <change>
    <description>Call reconfigureARSession when SyncMode changes in iOS SettingsView</description>
    <search>
===
            .onChange(of: arViewModel.currentSyncMode) { _, newMode in
                print("iOS Sync Mode changed to: \(newMode.rawValue)")
                // Add logic to reconfigure session if needed, e.g., add/remove image tracking
                // This might involve pausing and re-running the ARSession with a new configuration.
                // For now, just log the change.
                // Consider posting a notification like in visionOS if session reconfiguration is complex.
                arViewModel.isSyncedToImage = false // Reset sync status when mode changes
                arViewModel.isImageTracked = false
            }

            // Image Sync Status and Button
===
    </search>
    <content>
===
            .onChange(of: arViewModel.currentSyncMode) { _, newMode in
                print("iOS Sync Mode changed to: \(newMode.rawValue)")
                // Trigger session reconfiguration when the mode changes
                Task { @MainActor in
                    arViewModel.reconfigureARSession()
                }
                // Reset sync state immediately (reconfigureARSession also does this, but good for immediate UI feedback)
                arViewModel.isSyncedToImage = false
                arViewModel.isImageTracked = false
            }

            // Image Sync Status and Button
===
    </content>
  </change>
</file>